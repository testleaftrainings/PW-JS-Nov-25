ğŸ¯ What are we trying to achieve here?

When Salesforce tries to call its backend API:

POST  /aura?preloadActions


ğŸ‘‰ We donâ€™t want the real server to respond
ğŸ‘‰ We want Playwright to pretend to be the server
ğŸ‘‰ And send a fake (mocked) response

This helps in:

Testing UI without backend dependency

Faster tests

Stable tests (no flaky APIs)

Learning network behavior safely

ğŸ§© Step 1: Creating a Mocked Backend Response
const mockedResponse = {
  actions: [
    {
      id: "1",
      status: "SUCCESS",
      returnValue: { message: "This is a mocked response" }
    }
  ]
};

 What is this object?

This is fake data that looks like a real Salesforce Aura response.

Salesforce Aura framework usually returns data in this structure:

Field	Meaning
actions	List of backend actions executed
id	Unique action ID
status	Result of backend call (SUCCESS, ERROR)
returnValue	Actual data sent back to UI

 We are imitating Salesforce backend behavior

 Why this structure matters?

Front-end code expects:

response.actions[0].status === "SUCCESS"


If we return something else â†’ UI may break.

So mock must match real API shape, not random JSON.

ğŸ–¨ï¸ Step 2: Logging the Mocked Response
console.log(
  `Mocked Response Body:\n${JSON.stringify(mockedResponse, null, 2)}`
);

ğŸ” What is happening here?

JSON.stringify() converts JS object â†’ JSON string

null, 2 formats it nicely (indentation)

ğŸ“Œ Output looks like:

{
  "actions": [
    {
      "id": "1",
      "status": "SUCCESS",
      "returnValue": {
        "message": "This is a mocked response"
      }
    }
  ]
}

 Why log this?

Debugging


Verifying mock correctness

 Step 3: Fulfilling the Request (MOST IMPORTANT)
await route.fulfill({
  status: 200,
  contentType: "application/json",
  body: JSON.stringify(mockedResponse)
});

ğŸ”¥ This is the core of mocking

Here, Playwright says:

âŒ Donâ€™t send request to Salesforce
âœ… I will respond on behalf of the server

ğŸ§© Breakdown of route.fulfill()
Property	Meaning
status: 200	HTTP success response
contentType	Tells browser this is JSON
body	Actual response payload

ğŸ“Œ From browserâ€™s point of view:

â€œI called Salesforce and got a valid responseâ€

But actually â†’ Playwright faked it ğŸ˜

ğŸ” Step 4: Why else { route.continue() }?
} else {
  await route.continue();
}

ğŸ¤” Why is this needed?

Your page.route() intercepts ALL matching requests.

We mock only POST

Other requests (GET, OPTIONS, etc.) should go to real server

Without this?

âŒ Requests will hang
âŒ Page may never load
âŒ Test will timeout

ğŸ§  Simple Analogy (Great for Learners)

Think of this like Phone Call Redirection â˜ï¸

App â†’ calls Salesforce backend

Playwright intercepts the call

Playwright says:

â€œNo need to call Salesforce, Iâ€™ll answer for youâ€

And answers with:

{
  "status": "SUCCESS",
  "message": "This is a mocked response"
}

ğŸ§ª What happens in the UI?

Because of:

status: "SUCCESS"


ğŸ‘‰ Salesforce UI believes login & preload worked
ğŸ‘‰ App launcher loads
ğŸ‘‰ Test proceeds smoothly

Even if:

Backend is slow

Backend is down

Credentials are fake

